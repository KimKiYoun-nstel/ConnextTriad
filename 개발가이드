원인: 수신 EVT에 **실제 페이로드가 실리지 않음**. `ipc_adapter.cpp`에서 수신 콜백은 다음 형태로 EVT를 구성함:

```cpp
nlohmann::json evt = {
  {"evt","data"},
  {"topic", topic},
  {"type", type_name},
  {"display", display} // ← 변환된 요약만 담음
};
```

`display`는 `sample_to_json[type_name](data)`가 있을 때만 채워짐. 매핑이 없거나 변환에서 예외가 나면 코드가 `display = nullptr` 또는 의미 없는 `{"raw"}` 형태로 대체함. 따라서 UI는 “수신 이벤트”는 보지만 **내용은 비어 있음**.

추가 가능성: `type_name` 불일치. 콜백에서 사용하는 `dds::topic::topic_type_name<T>::value()` 값이 `sample_to_json`의 키와 조금이라도 다르면 매핑 실패 → `display` 비어 있음.

증거:

* `ReaderHolder`가 콜백으로 넘기는 것은 `AnyData(sample.data())`이며 타입은 정상 유지.
* `ipc_adapter.cpp`의 EVT 구성은 `display`만 포함. 원본 데이터나 안전한 기본 직렬화가 없음.
* `sample_to_json`에 없는 타입이거나 변환 실패 시 `display`가 null/placeholder가 됨.

해결 방향 요약:

* EVT에 `data` 또는 `payload`로 **원본 변환 결과**를 항상 포함. 매핑 없으면 최소한의 안전 직렬화(예: `StringMsg{text}`)라도 채움.
* `type_name`을 표준화하거나, `topic_to_type_` 매핑을 사용해 `sample_to_json` 조회 키를 일치시킴.

로그 추가 제안(정확한 위치와 내용):

1. `RtpDdsGateway/include/dds_type_registry.hpp`

* `ReaderHolder::ForwardingReaderListener::on_data_available`

  ```cpp
  LOG_DBG("DDS", "rx begin topic=%s type=%s", topic.c_str(), dds::topic::topic_type_name<T>::value());
  for (auto sample : r.take()) {
      auto& info = sample.info();
      LOG_DBG("DDS", "rx sample valid=%d inst=%lld ss=%d vs=%d is=%d ts=%ld",
              info.valid(), (long long)info.instance_handle().value(),
              (int)info.state().sample_state(), (int)info.state().view_state(),
              (int)info.state().instance_state(),
              (long)info.source_timestamp().to_microsecs());
      if (info.valid()) {
          // 그대로
      }
  }
  LOG_DBG("DDS", "rx end topic=%s", topic.c_str());
  ```
* `WriterHolder::write_any` catch에서

  ```cpp
  LOG_ERR("DDS", "any_cast fail type=%s what=%s",
          dds::topic::topic_type_name<T>::value(), e.what());
  ```

2. `RtpDdsGateway/src/dds_manager.cpp`

* `create_reader(...)` 성공 직후

  ```cpp
  LOG_INF("DDS", "reader ready domain=%d sub=%s topic=%s type=%s",
          domain_id, sub_name.c_str(), topic.c_str(), type_name.c_str());
  ```
* 리스너 장착 직후

  ```cpp
  LOG_DBG("DDS", "listener attached topic=%s", topic.c_str());
  ```
* `set_on_sample`에서 핸들러 설정 시

  ```cpp
  LOG_DBG("DDS", "on_sample handler installed");
  ```

3. `RtpDdsGateway/src/ipc_adapter.cpp`

* `mgr_.set_on_sample([...])` 람다의 시작부

  ```cpp
  LOG_DBG("IPC", "evt build start topic=%s type=%s", topic.c_str(), type_name.c_str());
  ```
* `sample_to_json` 조회 결과에 따라

  ```cpp
  bool mapped = (it != sample_to_json.end());
  LOG_DBG("IPC", "json mapper %s for type=%s", mapped?"hit":"miss", type_name.c_str());
  ```
* 변환 성공 시 요약 프리뷰(너무 길면 자름)

  ```cpp
  auto s = display.dump();
  if (s.size() > 256) s.resize(256);
  LOG_DBG("IPC", "display json preview=%s", s.c_str());
  ```
* 변환 실패/예외 시

  ```cpp
  LOG_WRN("IPC", "display build failed type=%s, fallback used", type_name.c_str());
  ```
* EVT 전송 직전

  ```cpp
  LOG_INF("IPC", "send EVT topic=%s type=%s has_display=%d",
          topic.c_str(), type_name.c_str(), !display.is_null());
  ```

4. `RtpDdsGateway/src/sample_factory.cpp`

* 각 변환 람다 내부 상단

  ```cpp
  LOG_DBG("SAMPLE", "to_json begin type=StringMsg");
  ```
* 예외 캐치 시

  ```cpp
  LOG_ERR("SAMPLE", "to_json error type=... msg=%s", e.what());
  ```

5. `ConnextControlUI/src/mainwindow.cpp`(수신 처리부)

* EVT 수신 시 CBOR→JSON 파싱 성공 여부, `display` 존재 여부, 키 필드 출력

  ```cpp
  appendLog(QString("[EVT] topic=%1 type=%2 has_display=%3 json=%4")
            .arg(topic).arg(type).arg(display_present).arg(pretty_json_truncated));
  ```

문제1의 직접적 원인 정리:

* `ipc_adapter.cpp`의 EVT 포맷이 **`display`만** 싣고, 매핑 실패 시 **실제 데이터가 빠짐**.
* `type_name` 키가 `sample_to_json`과 불일치하면 매핑 실패가 빈번.
* 결과적으로 UI는 “수신 이벤트”만 보고 **내용은 못 받음**.

즉시 점검 포인트:

* 런타임 로그로 `type_name`과 `sample_to_json` 히트 여부부터 확인.
* 히트인데도 비면 변환 람다 예외. 미스면 타입명 매핑 문제.
* 둘 다 아니면 UI가 `display`를 소비하지 않는 프로토콜 불일치. 그 경우 EVT에 `data` 필드로도 동일 JSON을 중복 포함하도록 설계 변경 필요.
