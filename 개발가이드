맞다. 아래 순서대로 반영하면 된다. VS 전환 방법은 제외했다.

# 1) 공용 래퍼 추가

`common/parser_client.hpp` 신규:

```cpp
#pragma once
#include <string>

#ifdef PARSER_LINK_STATIC
  // 정적 링크 경로: DLL 로더 불필요
  #include "parser_plugin.h"
  inline bool parser_from(const std::string& type, const std::string& in, std::string& out){
    size_t need=0; if(!parser_from_json(type.c_str(), in.c_str(), nullptr, &need) || need==0) return false;
    out.resize(need); return parser_from_json(type.c_str(), in.c_str(), out.data(), &need);
  }
  inline bool parser_to(const std::string& type, const std::string& in, std::string& out){
    size_t need=0; if(!parser_to_json(type.c_str(), in.c_str(), nullptr, &need) || need==0) return false;
    out.resize(need); return parser_to_json(type.c_str(), in.c_str(), out.data(), &need);
  }
#else
  // 동적 로딩 경로
  #include "parser_loader.hpp"
  inline Parser& _parser_singleton(){ static Parser p = load_parser("./parsers/ngva_parser.dll"); return p; }
  inline bool parser_from(const std::string& type, const std::string& in, std::string& out){
    auto& p=_parser_singleton(); return p.ok() && call_from(p, type, in, out);
  }
  inline bool parser_to(const std::string& type, const std::string& in, std::string& out){
    auto& p=_parser_singleton(); return p.ok() && call_to(p, type, in, out);
  }
#endif
```

# 2) 루트 CMake 단일 스위치

`CMakeLists.txt`(루트) 상단에 추가:

```cmake
# 단일 스위치: dynamic | static
set(PARSER_LINK_MODE "dynamic" CACHE STRING "dynamic or static")
string(TOLOWER "${PARSER_LINK_MODE}" _PARSER_LINK_MODE)
if(NOT _PARSER_LINK_MODE STREQUAL "dynamic" AND NOT _PARSER_LINK_MODE STREQUAL "static")
  message(FATAL_ERROR "PARSER_LINK_MODE must be dynamic or static")
endif()
message(STATUS "PARSER_LINK_MODE=${_PARSER_LINK_MODE}")

# 코드 매크로 전달용 인터페이스 타깃
add_library(parser_config INTERFACE)
if(_PARSER_LINK_MODE STREQUAL "static")
  target_compile_definitions(parser_config INTERFACE PARSER_LINK_STATIC=1)
endif()

# 기존 서브디렉터리
add_subdirectory(common)
add_subdirectory(parsers/ngva)
add_subdirectory(RtpDdsGateway)
add_subdirectory(ConnextControlUI)
```

# 3) 파서 라이브러리 CMake 연동

`parsers/ngva/CMakeLists.txt`에 `parser_config` 연결:

```cmake
# ... (코드 생성 커맨드는 기존대로)

add_library(parser_core_obj OBJECT
  src/parser_core.cpp
  ${GEN_DIR}/parser_core_gen.cpp
)
target_include_directories(parser_core_obj PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include ${GEN_DIR})
target_link_libraries(parser_core_obj PUBLIC parser_config)  # <- 매크로 전파

add_library(ngva_parser_shared SHARED $<TARGET_OBJECTS:parser_core_obj> src/exports.cpp)
set_target_properties(ngva_parser_shared PROPERTIES OUTPUT_NAME "ngva_parser")
target_include_directories(ngva_parser_shared PUBLIC ${CMAKE_SOURCE_DIR}/common)

add_library(ngva_parser_static STATIC $<TARGET_OBJECTS:parser_core_obj> src/exports.cpp)
set_target_properties(ngva_parser_static PROPERTIES OUTPUT_NAME "ngva_parser")
target_include_directories(ngva_parser_static PUBLIC ${CMAKE_SOURCE_DIR}/common)
```

# 4) UI CMake 분기

`ConnextControlUI/CMakeLists.txt`:

```cmake
target_link_libraries(ConnextControlUI PRIVATE parser_config)

if(PARSER_LINK_MODE STREQUAL "dynamic")
  target_link_libraries(ConnextControlUI PRIVATE parser_loader)
  add_custom_command(TARGET ConnextControlUI POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:ConnextControlUI>/parsers
    COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:ngva_parser_shared>
            $<TARGET_FILE_DIR:ConnextControlUI>/parsers/)
else()
  target_link_libraries(ConnextControlUI PRIVATE ngva_parser_static)
endif()
```

# 5) Gateway CMake 분기

`RtpDdsGateway/CMakeLists.txt`:

```cmake
target_link_libraries(RtpDdsGateway PRIVATE parser_config)

if(PARSER_LINK_MODE STREQUAL "dynamic")
  target_link_libraries(RtpDdsGateway PRIVATE parser_loader)
  add_custom_command(TARGET RtpDdsGateway POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E make_directory $<TARGET_FILE_DIR:RtpDdsGateway>/parsers
    COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:ngva_parser_shared>
            $<TARGET_FILE_DIR:RtpDdsGateway>/parsers/)
else()
  target_link_libraries(RtpDdsGateway PRIVATE ngva_parser_static)
endif()
```

# 6) 사용 코드 교체

두 파일에서 동일하게 적용.

## UI: `ConnextControlUI/src/mainwindow.cpp`

* 교체:

  ```cpp
  // #include "parser_loader.hpp"  // 제거
  #include "parser_client.hpp"     // 추가
  ```
* 전송 전:

  ```cpp
  std::string out;
  if (parser_from("P_Alarms_PSM::C_Actual_Alarm", text, out)) text.swap(out);
  ```
* EVT 표시 전:

  ```cpp
  std::string uo;
  if (parser_to(type, display.dump(), uo)) display = nlohmann::json::parse(uo, nullptr, false);
  ```

## Gateway: `RtpDdsGateway/src/ipc_adapter.cpp`

* 교체:

  ```cpp
  // #include "parser_loader.hpp"  // 제거
  #include "parser_client.hpp"     // 추가
  ```
* `op=="write"` 처리에서 publish 직전:

  ```cpp
  std::string canon;
  if (parser_from(type, text, canon)) text.swap(canon);
  ```
* `set_on_sample` 람다에서 `display` 생성 후:

  ```cpp
  std::string uo;
  if (parser_to(type_name, display.dump(), uo)) {
      auto p = nlohmann::json::parse(uo, nullptr, false);
      if (!p.is_discarded()) display = std::move(p);
  }
  ```

# 7) 산출물 배치 확인(동적 모드만)

* 빌드 후 `ConnextControlUI/…/parsers/ngva_parser.dll`
* 빌드 후 `RtpDdsGateway/…/parsers/ngva_parser.dll`

# 8) 체크리스트

* `common/parser_client.hpp`가 두 타깃 모두에서 포함되는지.
* 루트에서 `parser_config`가 먼저 정의되는지.
* 한 모드만 링크되도록 CMake 분기가 중복되지 않는지.
* 동적 모드에서 `parser_loader` 링크 누락이 없는지.
* 정적 모드에서 `ngva_parser_static` 링크 누락이 없는지.

이대로면 하나의 스위치(`PARSER_LINK_MODE`)로 CMake와 소스가 동시에 분기된다.
